# How does this book work?

This edition of the book categorizes and describes 62 different monitoring
tools. I've used a hierarchal taxonomy composed of 5 taxa to categorize these
tools, and then I've provided a summary of each tool in the form of a small
questionaire to give you a sense of how the tool does what it does, how well it
gets along with other tools, and how well it fits into your
environment/culture/stack. 

## The Taxa 
There are four top-level categories, and each have a varying number of
classifications: 

### Operations Burden
Whom do you want to run your monitoring tool? The classifications are: 

* Traditional
* Hosted
* Appliances and Sensors

Traditional apps are on-premise. You download them and run them on a machine
you own (or lease or whatever). Hosted apps, also known as SaaS (Software as a
Service), are run for you by the maker of the software, and you typically
interact with it via a combination of Browser-based interfaces and publicly
facing API's. Appliances and sensors are hardware solutions, that is, the
vendor ships you a physical system that you plug into your network somewhere.

### Pay Model
How do you want to pay for your monitoring tool? The classifications are:

* Free/Open
* Commercial
* Freemium
* Free/Closed
* Subscription
* Hardware

Opensource tools cost $0 to obtain and come with their source code (as the more
cynical amoung us might say: "software you pay for in blood and tears").
Commercially licensed costs money to obtain (legally) and is usually
distributed in binary form. This category includes demo software that's
free-to-use for a limited time, as well as tools whose free-to-use tier are too
limited to run a small start-up on.

Freemium software is free to use but comes with a paid premium component or
usage tier. Commercial tools that have a usable free tier can be found here. By
usable I mean the free tier provides the base-line operability a resonable
person would consider running a small startup on. 

Free/Closed software doesn't cost money to obtain. Shareware and Nagware tools
can be found in this category.

Most hosted and SaaS monitoring tools use a subscription-based model where the
tool is free to use for 14-30 days, and then costs some amount of money per
month. 

And finally the hardware model charges a one-time fee that covers the price of
the hardware, which is free subsequently free to use. Vendors that charge
ongoing maintenence for their hardware can be found here. 

### Activity Model
Do you need a tool to collect measurements, or process measurements or both?

* Collectors
* Processors
* Monoliths

Collectors are things like monitoring agents, instrumentation libraries and
sensors -- tools designed primarily to measure things and make observations,
and then ship those measurements to other tools. 

Processors are data visualization tools, time series DB's and stream processing
systems. They're designed primarily to accept and/or process data from other tools.

Monoliths were designed to be all-in-one solutions. It's (probably) possible to
import/export data from these tools (with varying degrees of pain and
frustration on your part), but they were _designed_ to consume the data that
they, themselves collect. Most traditional operations-oriented "monitoring"
tools (eg openview, patrol, Nagios et. al) fit in this category.

### Focus
What do you need your tool to actually monitor?

* System Availability
* App/DB Performance
* Networks
* Log/Metric Processing
* Storage Analysis
* Platform-Specific

System Availability tools seek to answer the question: "Is it up?". Any tool
that was primarily designed to check for system or service availability at a
one-minute or greater resolution will be found here. Most classical
operations-centric monitoring tools like Nagios fall into this category.

App/DB Performance Monitoring Tools insert themselves into popular databases
and language interpretors for the purpose of analyzing their performance. This
is usually done by monkey-patching the interpretor or some other
magical/nefarious bytecode/binary abstraction, wrapping the thing you're using
inside a blanket of instrumentation code. These tools are language/DB specific
(ie make sure it supports your stack before you buy it) and can give very
detailed performance data at a highly granular resolution on databases like
MySQL or even on custom apps by, for example, instrumenting the JVM. Examples
include New Relic, Appneta, and Vivid Cortex.

Network Analysis tools are specifically designed to monitor and analyze network
availability, performance, and content. Packet taps, SNMP collectors, Netflow,
and SFlow related tools can be found herein along with tools that primarily
ingest packet-traffic as a diagnostic source.

Log/Metric processing (otherwise known as data-centric tools) were designed to
collect or accept ad-hoc metrics and log data and do something useful with it,
such as visualizing it (drawing graphs), parsing it, transforming it, alerting
on it, and possibly forwarding it to other tools. Examples include Splunk,
Heka, Graphite, Riemann and Librato. Many tools tow the line between System
Availability, App/DB Performance and Data-Processing, so I've made some
probably subjective calls here. If you think something got miscategorized 
keep reading.

Storage/Persistence tools specialize in analyzing SAN's and other distributed
storage technologies, and Platform-specific tools were created alongside a
specific, pre-existing platform in order to monitor that particular platform.
AWS/Heroku/Rackspace and etc.. monitoring offerings fall into this category.

## Great categories I guess, now what?
Like I said, the taxonomy is hierarchal, so from those top-level taxa we build
categorical paths like: traditional -> free/open -> monolithic ->
system_availability which happens to be the most popular taxa (12 tools
categorize there).

Not every possible path contains tools. In fact, the 62 tools herein categorize
into 25 different taxonimic paths. Those are: 

* hosted.freemium.monoliths.apm
* hosted.freemium.monoliths.data
* hosted.freemium.monoliths.platform_specific
* hosted.freemium.processors.data
* hosted.subscription.monoliths.apm
* hosted.subscription.monoliths.data
* hosted.subscription.monoliths.platform_specific
* hosted.subscription.monoliths.system
* hosted.subscription.processors.data
* hosted.subscription.processors.system
* traditional.commercial.monoliths.apm
* traditional.commercial.monoliths.network
* traditional.commercial.monoliths.platform_specific
* traditional.commercial.monoliths.system
* traditional.free_open.collectors.data
* traditional.free_open.collectors.system
* traditional.free_open.monoliths.data
* traditional.free_open.monoliths.network
* traditional.free_open.monoliths.system
* traditional.free_open.processors.data
* traditional.free_open.processors.network
* traditional.free_open.processors.system
* traditional.freemium.monoliths.data
* traditional.freemium.monoliths.network
* traditional.freemium.monoliths.system

Each of these paths is represented as a chapter in Part 2, and each tool is a
section in the chapter that corresponds to it's category. The colored tabs in
the margin were designed to help you find these paths quickly, so if you know
what you want in terms of those categories (as most of us do), you can thumb
through the book and pretty quickly find the tools listed in the category
you're interested in exploring. Once there, you should hopefully be able to
compare the tools by their descriptions and decide which of them are worth
exploring further.

Since each of these paths is a chapter, and each tool a top-level section in
that chapter, the table of contents also serves as a useful outline that can
point you to the page of the section/tool you're looking for (which is, I
suppose, somewhat a-priori the entire point of a table of contents in the first
place, but it's especially appropos in this work so I thought I'd point it
out). I've also added a few appendecies that list the tools in different ways.
There is, for example, an appendix for each focus (ie. EVERY tool with a
Network focus, etc..), and listings of tools with conflicting categories (eg
ostensibly SaaS tools with an on-prem option). If you have an electronic
version of this book, the categories above should be clickable (they'll also be
clickable via the TOC). 

## Tags
There are also a series of tags at the bottom of each tool section which are
designed to help identify tools that contain features I feel like I should warn
you about. It's not my intention to shame anyone with these, but
engineer-to-engineer they are the things I would want to know. These include
but are not limited to:

* piecharts (for tools that are proud of their use of pie charts)
* on-prem-option (for tools that are categorized SaaS but have an on-premise option)
* on-hosted-option (for tools that are categorized traditional but have a hosted option)
* oss-option (for commercial tools with a useable open-source core)
* SPOF (for tools that can't be distributed or are built on an spof data-store)

## Why didn't you include awesome monitoring tool X?
Because I hate you. Just kidding (I actually think you're pretty cool). The
list of tools I've documented here were taken from James Turnbell's 2015
Monitoring Survey results, which you can see for yourself at
https://kartar.net/2015/08/monitoring-survey-2015---tools/. 

In this book you'll find documented every tool that has a minimum of two
respondants in the Katar survey which is actually a monitoring tool (for
example "MongoDB Manager Service" is well...  MongoDB's manager service, and
not really a monitoring tool). 

## How did you decide what tools to include?
See the question above.

## Why is everything you said about awesome tool X wrong and also, how come you're stupid? 
Sorry about that. This was a lot of research and it's not just possible but
probable that I've misrepresented something. I assure you, it wasn't personal,
and I'm happy to accept PR's on any of the description content and/or to
discuss recategorization and the addition of new categories. Simply clone the
git-repo here: https://github.com/librato/taxonomy and shoot me an issue with
an accompanying PR. I badly want this to be a living, breathing community
project and I consider this to be only the beginning of the conversation.

